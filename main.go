package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"strings"

	"golang.org/x/tools/go/packages"
)

var (
	acceptorTypes     = flag.String("type", "", "comma-separated list of acceptor types; must be set")
	visitorName       = flag.String("vType", "Visitor", "visitor interface name")
	visitMethodPrefix = flag.String("vPrefix", "Visit", "visitor's visit method prefix; e.g. VisitType() if vPrefix is Visit and visit target is Type.")
	acceptMethodName  = flag.String("accept", "Accept", "acceptor's accept method name")
	output            = flag.String("output", "", "output file name; default srcdir/<vt>_mkvisitor.go, vt is vType in lowercase")
)

const usage = `Usage of mkvisitor:
  mkvisitor [flags] -type T [directory]
  mkvisitor [flags] -type T files...  # Must be a single package
Flags:`

func Usage() {
	fmt.Fprintln(os.Stderr, usage)
	flag.PrintDefaults()
}

func isDirectory(p string) bool {
	x, err := os.Stat(p)
	if err != nil {
		log.Fatal(err)
	}
	return x.IsDir()
}

func main() {
	log.SetFlags(0)
	log.SetPrefix("mkvisitor: ")
	flag.Usage = Usage
	flag.Parse()

	if len(*acceptorTypes) == 0 {
		log.Fatal("type must be set")
	}
	if *visitorName == "" {
		log.Fatal("vType cannot be empty")
	}
	if *visitMethodPrefix == "" {
		log.Fatal("vPrefix cannot be empty")
	}
	if *acceptMethodName == "" {
		log.Fatal("accept cannot be empty")
	}
	acceptors := strings.Split(*acceptorTypes, ",")

	args := flag.Args()
	if len(args) == 0 {
		args = []string{"."}
	}
	var dir string
	if len(args) == 1 && isDirectory(args[0]) {
		dir = args[0]
	} else {
		dir = filepath.Dir(args[0])
	}

	g := Generator{}
	g.parsePackage(args)

	g.Printf("// Code generated by \"mkvisitor %s\"; DO NOT EDIT.\n", strings.Join(os.Args[1:], " "))
	g.Println()
	g.Printf("package %s\n", g.pkg.name)
	g.Println()
	g.Println(`import "fmt"`)

	g.generate(*acceptMethodName, *visitorName, *visitMethodPrefix, acceptors)

	outputName := *output
	if outputName == "" {
		baseName := fmt.Sprintf("%s_mkvisitor.go", *visitorName)
		outputName = filepath.Join(dir, strings.ToLower(baseName))
	}
	if err := os.WriteFile(outputName, g.format(), 0600); err != nil {
		log.Fatalf("write file %v", err)
	}
}

type Generator struct {
	buf bytes.Buffer
	pkg *Package
}

func (s *Generator) Printf(format string, v ...interface{}) {
	fmt.Fprintf(&s.buf, format, v...)
}

func (s *Generator) Println(v ...interface{}) {
	fmt.Fprintln(&s.buf, v...)
}

type Package struct {
	name string
	defs map[string]bool
}

func (s *Generator) parsePackage(patterns []string) {
	pkgs, err := packages.Load(&packages.Config{
		Mode: packages.NeedTypesInfo | packages.NeedTypes | packages.NeedName,
	}, patterns...)
	if err != nil {
		log.Fatal(err)
	}
	if len(pkgs) != 1 {
		log.Fatalf("%d packages found", len(pkgs))
	}
	s.addPackage(pkgs[0])
}

func (s *Generator) addPackage(pkg *packages.Package) {
	defs := map[string]bool{}
	for k, v := range pkg.TypesInfo.Defs {
		if v == nil {
			continue
		}
		if _, ok := v.Type().Underlying().(*types.Struct); !ok {
			continue
		}
		defs[k.String()] = true
	}
	s.pkg = &Package{
		name: pkg.Name,
		defs: defs,
	}
}

func (s *Generator) generate(acceptMethodName, visitorName, visitPrefix string, targetTypeNames []string) {
	for _, t := range targetTypeNames {
		if _, exist := s.pkg.defs[t]; !exist {
			log.Fatalf("%s not found", t)
		}
	}
	s.generateVisitorInterface(visitorName, visitPrefix, targetTypeNames)
	s.generateAcceptMethods(acceptMethodName, visitorName, visitPrefix, targetTypeNames)
	s.generateDefaultVisitor(visitorName, visitPrefix, targetTypeNames)
	s.generateAssignSwitch(visitorName, visitPrefix, targetTypeNames)
}

func (s *Generator) generateVisitorInterface(visitorName, visitPrefix string, targetTypeNames []string) {
	s.Printf("type %s interface {\n", visitorName)
	for _, t := range targetTypeNames {
		s.generateVisitMethodDecl(visitPrefix, t)
	}
	s.Println("}")
}

func (s *Generator) generateVisitMethodDecl(visitPrefix, targetTypeName string) {
	s.Printf("%s(*%s)\n",
		s.visitMethodName(visitPrefix, targetTypeName),
		targetTypeName,
	)
}

func (*Generator) visitMethodName(visitPrefix, targetTypeName string) string {
	return fmt.Sprintf("%s%s", visitPrefix, strings.Title(targetTypeName))
}

// generates accept methods for each target type.
func (s *Generator) generateAcceptMethods(acceptMethodName, visitorName, visitPrefix string, targetTypeNames []string) {
	for _, t := range targetTypeNames {
		s.generateAcceptMethod(acceptMethodName, visitorName, visitPrefix, t)
	}
}

func (s *Generator) generateAcceptMethod(acceptMethodName, visitorName, visitPrefix, targetTypeName string) {
	s.Printf("func (s *%s) %s(v %s){v.%s(s)}\n",
		targetTypeName,
		acceptMethodName,
		visitorName,
		s.visitMethodName(visitPrefix, targetTypeName),
	)
}

// generates default visitor implementation.
func (s *Generator) generateDefaultVisitor(visitorName, visitPrefix string, targetTypeNames []string) {
	defaultVisitorName := fmt.Sprintf("%sDefault", visitorName)
	s.Printf("type %s struct {}\n", defaultVisitorName)
	for _, t := range targetTypeNames {
		s.generateDefaultVisitorMethod(defaultVisitorName, visitPrefix, t)
	}
}

func (s *Generator) generateDefaultVisitorMethod(defaultVisitorName, visitPrefix, targetTypeName string) {
	s.Printf("func (s *%s) %s(_ *%s){}\n",
		defaultVisitorName,
		s.visitMethodName(visitPrefix, targetTypeName),
		targetTypeName,
	)
}

// generates a function to call the correct visit method for each target type.
func (s *Generator) generateAssignSwitch(visitorName, visitPrefix string, targetTypeNames []string) {
	const (
		visitorArg   = "visitor"
		interfaceArg = "v"
	)
	funcName := fmt.Sprintf("%sSwitch", visitPrefix)
	s.Printf("func %s(%s %s, %s interface{}) {\n",
		funcName,
		visitorArg,
		visitorName,
		interfaceArg,
	)
	s.Printf(`switch %[1]s := %[1]s.(type) {`, interfaceArg)
	s.Println()
	for _, t := range targetTypeNames {
		s.Printf(`case *%s: %s.%s(v)`, t, visitorArg, s.visitMethodName(visitPrefix, t))
		s.Println()
	}
	panicMsg := fmt.Sprintf("%s cannot switch %s", funcName, "%#v")
	s.Printf(`default: panic(fmt.Sprintf("%s", %s))`, panicMsg, interfaceArg)
	s.Println()
	s.Println("}")
	s.Println("}")
}

func (s *Generator) format() []byte {
	src, err := format.Source(s.buf.Bytes())
	if err != nil {
		log.Fatalf("format failure %v", err)
	}
	return src
}
